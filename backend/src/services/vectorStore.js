// Fast, In-Memory Vector Store for RAG

/**
 * structure of store:
 * [
 *   {
 *      tableName: 'users',
 *      schemaText: 'TABLE: users \n  Columns: id (integer), name (varchar)...',
 *      embedding: [0.12, 0.45, -0.22, ...] // Generated by Ollama
 *   }
 * ]
 */
let memoryStore = [];

/**
 * Saves a table's schema, mathematical embedding, and AI summary to memory.
 */
function addTableEmbedding(
  tableName,
  schemaText,
  embedding,
  summary = "",
  dbType = "postgres",
) {
  if (!embedding || embedding.length === 0) {
    throw new Error("Invalid embedding vector provided.");
  }

  const data = { tableName, schemaText, embedding, summary, dbType };

  // Check if table already exists, update if so
  const existingIndex = memoryStore.findIndex((t) => t.tableName === tableName);
  if (existingIndex >= 0) {
    memoryStore[existingIndex] = data;
  } else {
    memoryStore.push(data);
  }
  console.log(
    `[Vector Store] Table "${tableName}" saved ${summary ? "(with AI summary)" : ""}. Memory store size: ${memoryStore.length}`,
  );
}

/**
 * Helper formula: Calculates the Cosine Similarity (angle) between two vectors.
 * 1.0 means perfectly identical directions (identical semantic meaning).
 * -1.0 means exactly opposite.
 */
function cosineSimilarity(vecA, vecB) {
  if (vecA.length !== vecB.length) return 0;

  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    normA += vecA[i] * vecA[i];
    normB += vecB[i] * vecB[i];
  }

  if (normA === 0 || normB === 0) return 0;
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

/**
 * Searches the memory store for the top K tables using Hybrid Search (Vector + Keyword)
 */
function searchSimilarTables(
  questionEmbedding,
  questionText = "",
  limit = 5,
  dbType = null,
) {
  if (memoryStore.length === 0) return [];

  const lowerQuestion = questionText.toLowerCase();

  // Filter by dbType if provided
  const targetStore = dbType
    ? memoryStore.filter((item) => item.dbType === dbType)
    : memoryStore;

  if (targetStore.length === 0) return [];

  // Calculate similarity score between the question and every table in the filtered store
  const scoredTables = targetStore.map((storeObj) => {
    let score = cosineSimilarity(questionEmbedding, storeObj.embedding);

    // KEYWORD BOOST: Split camelCase table names into individual keywords
    // (e.g. "userInfo" -> ["user", "info"])
    const tableName = storeObj.tableName;
    const keywords = tableName
      .replace(/([A-Z])/g, " $1")
      .toLowerCase()
      .split(" ");

    let keywordMatch = false;
    for (const kw of keywords) {
      if (kw.length < 3) continue; // Skip short words like "id"

      // Check if keyword or its singular form is in the question
      const singularKw = kw.endsWith("s") ? kw.slice(0, -1) : kw;
      if (
        lowerQuestion.includes(kw) ||
        (singularKw.length > 3 && lowerQuestion.includes(singularKw))
      ) {
        keywordMatch = true;
        break;
      }
    }

    if (keywordMatch || lowerQuestion.includes(tableName.toLowerCase())) {
      score += 0.4; // Reduced boost to prevent noise from overpowering semantic similarity
    }

    return {
      tableName: storeObj.tableName,
      schemaText: storeObj.schemaText,
      summary: storeObj.summary,
      dbType: storeObj.dbType, // Added dbType here
      score: score,
    };
  });

  // Sort descending by score (highest similarity first)
  scoredTables.sort((a, b) => b.score - a.score);

  // Return the top K closest matches
  return scoredTables.slice(0, limit);
}

/**
 * Returns the raw string containing only the top 5 schemas joined together.
 */
function getTopSchemasString(
  questionEmbedding,
  questionText = "",
  limit = 5,
  dbType = null,
) {
  const topMatches = searchSimilarTables(
    questionEmbedding,
    questionText,
    limit,
    dbType,
  );

  let combinedSchema = "";
  for (const match of topMatches) {
    combinedSchema += `SOURCE: ${match.dbType}\n`;
    if (match.summary) {
      combinedSchema += `PURPOSE: ${match.summary}\n`;
    }
    combinedSchema += match.schemaText + "\n\n";
  }

  const matchedNames = topMatches
    .map((m) => `${m.tableName} (${(m.score * 100).toFixed(1)}%)`)
    .join(", ");
  console.log(`[Vector Store] Top hybrid matches: ${matchedNames}`);

  return combinedSchema.trim();
}

/**
 * Wipes the store (useful for server restarts/schema reloads)
 */
function clearStore() {
  memoryStore = [];
}

module.exports = {
  addTableEmbedding,
  searchSimilarTables,
  getTopSchemasString,
  clearStore,
  cosineSimilarity,
};
