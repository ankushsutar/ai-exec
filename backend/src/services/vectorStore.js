// Fast, In-Memory Vector Store for RAG

/**
 * structure of store:
 * [
 *   {
 *      tableName: 'users',
 *      schemaText: 'TABLE: users \n  Columns: id (integer), name (varchar)...',
 *      embedding: [0.12, 0.45, -0.22, ...] // Generated by Ollama
 *   }
 * ]
 */
let memoryStore = [];

/**
 * Saves a table's schema and its mathematical embedding to memory.
 */
function addTableEmbedding(tableName, schemaText, embedding) {
    if (!embedding || embedding.length === 0) {
        throw new Error('Invalid embedding vector provided.');
    }

    // Check if table already exists, update if so
    const existingIndex = memoryStore.findIndex(t => t.tableName === tableName);
    if (existingIndex >= 0) {
        memoryStore[existingIndex] = { tableName, schemaText, embedding };
    } else {
        memoryStore.push({ tableName, schemaText, embedding });
    }
    console.log(`[Vector Store] Table "${tableName}" saved. Memory store size: ${memoryStore.length}`);
}

/**
 * Helper formula: Calculates the Cosine Similarity (angle) between two vectors.
 * 1.0 means perfectly identical directions (identical semantic meaning).
 * -1.0 means exactly opposite.
 */
function cosineSimilarity(vecA, vecB) {
    if (vecA.length !== vecB.length) return 0;

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < vecA.length; i++) {
        dotProduct += vecA[i] * vecB[i];
        normA += vecA[i] * vecA[i];
        normB += vecB[i] * vecB[i];
    }

    if (normA === 0 || normB === 0) return 0;
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

/**
 * Searches the memory store for the top K tables using Hybrid Search (Vector + Keyword)
 */
function searchSimilarTables(questionEmbedding, questionText = '', limit = 5) {
    if (memoryStore.length === 0) return [];

    const lowerQuestion = questionText.toLowerCase();

    // Calculate similarity score between the question and every table in memory
    const scoredTables = memoryStore.map(storeObj => {
        let score = cosineSimilarity(questionEmbedding, storeObj.embedding);

        // KEYWORD BOOST: If the exact table name is mentioned in the question, 
        // give it a massive semantic boost to ensure it stays in the Top 5.
        if (lowerQuestion.includes(storeObj.tableName.toLowerCase())) {
            score += 0.5; // Massive boost for exact hardware match
        }

        return {
            tableName: storeObj.tableName,
            schemaText: storeObj.schemaText,
            score: score
        };
    });

    // Sort descending by score (highest similarity first)
    scoredTables.sort((a, b) => b.score - a.score);

    // Return the top K closest matches
    return scoredTables.slice(0, limit);
}

/**
 * Returns the raw string containing only the top 5 schemas joined together.
 */
function getTopSchemasString(questionEmbedding, questionText = '', limit = 5) {
    const topMatches = searchSimilarTables(questionEmbedding, questionText, Math.min(limit, memoryStore.length));

    let combinedSchema = '';
    for (let match of topMatches) {
        combinedSchema += match.schemaText + '\n\n';
    }

    const matchedNames = topMatches.map(m => `${m.tableName} (${(m.score * 100).toFixed(1)}%)`).join(', ');
    console.log(`[Vector Store] Top hybrid matches: ${matchedNames}`);

    return combinedSchema.trim();
}

/**
 * Wipes the store (useful for server restarts/schema reloads)
 */
function clearStore() {
    memoryStore = [];
}

module.exports = {
    addTableEmbedding,
    searchSimilarTables,
    getTopSchemasString,
    clearStore
};
